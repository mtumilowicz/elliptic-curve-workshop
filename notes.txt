* references
    * https://habr.com/en/post/692072/

* take a look here: https://github.com/mtumilowicz/cryptography-math-basics

## preface
* goals of this workshop
    * introduction to elliptic curves
        * addition
        * multiplication
    * introduction to elliptic curves over finite fields
        * understanding what is the difference to elliptic curves over plane
        * understanding why they are useful in cryptography
    * understanding how ECDSA works
* workshop plan
    * implement function to sign a message according to ECDSA spec

## basics
* equation for an elliptic curve: y² = x³ + ax + b
    * https://www.desmos.com/calculator/wwpunn6ipg?lang=en
* properties
    * symmetric along the x-axis
        * for any point on the curve A, we can get its mirror point, called -A, by simply mirroring its y coordinate
    * if we draw a line through any of two points not lying on a vertical line, it will intersect the curve
    at exactly one more point
        * reflection of that point is called the sum of A and B
    * if we draw a tangent line through any point A lying on a curve, it will intersect the curve at exactly one point
        * call this point -2A
        * with that we can define multiplication by number
            * A + 2A = 3A
            * example, to get 10A:
              2A = A + A
              4A = 2A + 2A
              8A = 4A + 4A
              10A = 8A + 2A
* summary
    * what we can do with points on a curve
        * addition of two points: (A + B)
        * subtraction of two points: A — B = (A + (-B))
        * multiplication by two: 2A
        * multiplying by any integer: k * Point
    * what we can’t do
        * multiplication of two points
        * division of a point over another point
        * division of a point over a scalar value
            * observation: we can multiply a point by any integer, but there is no way to get the integer back
            * makes the elliptic curves very good for cryptography

## over finite fields
* elliptic curve: `y² = x³ + ax + b`
* elliptic curve over finite field: `y² mod p = x³ + ax + b mod p`
    * both parts of the equation are now under the modulo p
* to define an elliptic curve, we now need three variables: a, b, and p
    * p is called the order of an elliptic curve
    * example
        * secp256k1 (used in Bitcoin)
            * a=0
            * b=7
            * p=115792089237316195423570985008687907853269984665640564039457584007908834671663
        * visualisation: https://graui.de/code/elliptic2/
            * parameters
                * a = 0
                * b = 7
                * p = 11
* properties
    * has a finite set of points
    * works like an elliptic curve
        * preserves all the properties and formulas of the "original" elliptic curve
    * only difference: slightly modify formulas by executing them mod p
        * multiplicative inverse can be found by the Extended Euclidean algorithm - O(log(n))
* order of the point
    * every point on a curve has its own order n
        * example
            * if the order n of point C is 12, it means that
            * 12C = 0
            * 13C = C, 16C = 4C, 27C = 3C

## ECDSA (Elliptic Curves Digital Signature Algorithm)
* what we have
    * set of "global" public variables of elliptic curve
        * config (a, b, p)
        * Point G (Generator Point)
            * lies on the curve
        * Order n of point G
    * PrivateKey
        * any random integer
        * kept in secret by its "owner"
    * PublicKey
        * just point on the curve
        * there is no way to exctact the PrivateKey back
* signing a message
    * what we have
        * PrivateKey
        * message
    * algorithm
        1. generate a random integer k
            * it should be a big number in range `[1, n-1]`
        1. calculate point `R = G * k`
        1. signature: a pair of integers `(r, s)`
            * `r = Rx mod n`
                * (if r == 0 start again with new k)
            * `s = (message + r*PrivateKey)*k^(-1) mod n`
                * k^(-1) is multiplicative inverse of k
* verifying a signature
    * what we have
        * PublicKey
        * message
        * signature `(r, s)`
    * algorithm
        1. calculate U
            * `U = message * s^(-1) mod n`
                * s^(-1) is multiplicative inverse of s
        1. calculate V
            * `V = r*s^(-1) mod n`
                * s^(-1) is multiplicative inverse of s
        1. calculate point C
            * C = U * G + V * PublicKey
        1. if c.x mod n = r => valid
    * proof
        * `C = U * G + V * PublicKey`
        * substitute with definitions
            * `C = message * s^(-1) * G + r * s^(-1) * G * PrivateKey`
            * `C = G * s^(-1) * (message + r * PrivateKey)`
                * from the signing algorithm: `s = (message + r * PrivateKey) * k^(-1)`
                    * `s^(-1) = (message + r * PrivateKey)^(-1) * k`
                    * after substitution: `C = Gk`
                        * thus, if the signature is correct, the x coordinate of C mod n is equal to r
                        (which is, by its definition, the same x coordinate of G * k)
                            * from signing algo: r = Rx mod n, where = Gk